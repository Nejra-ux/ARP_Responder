library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_arp_responder_scenarij1 is
end entity;

architecture tb of tb_arp_responder_scenarij1 is

  constant tclk : time := 10 ns;

  signal clock     : std_logic := '1';
  signal reset     : std_logic := '1';

  signal in_ready  : std_logic;
  signal in_valid  : std_logic := '0';
  signal in_data   : std_logic_vector(7 downto 0) := (others => '0');
  signal in_sop    : std_logic := '0';
  signal in_eop    : std_logic := '0';

  signal out_ready : std_logic := '1';
  signal out_valid : std_logic;
  signal out_data  : std_logic_vector(7 downto 0);
  signal out_sop   : std_logic;
  signal out_eop   : std_logic;

  type byte_array_t is array (natural range <>) of std_logic_vector(7 downto 0);

  -- ARP Request: TPA = 192.168.1.1 (match)
  constant arp_req : byte_array_t(0 to 41) := (
    x"FF", x"FF", x"FF", x"FF", x"FF", x"FF",               -- dst MAC (broadcast)
    x"00", x"11", x"22", x"33", x"44", x"55",               -- src MAC (requester)
    x"08", x"06",                                           -- EtherType ARP
    x"00", x"01", x"08", x"00", x"06", x"04", x"00", x"01", -- HTYPE,PTYPE,HLEN,PLEN,OPER=Request
    x"00", x"11", x"22", x"33", x"44", x"55",               -- SHA
    x"C0", x"A8", x"01", x"64",                             -- SPA = 192.168.1.100
    x"00", x"00", x"00", x"00", x"00", x"00",               -- THA = unknown
    x"C0", x"A8", x"01", x"01"                              -- TPA = 192.168.1.1 (DUT)
  );

  -- O?ekivani ARP Reply
  constant arp_reply_exp : byte_array_t(0 to 41) := (
    x"00", x"11", x"22", x"33", x"44", x"55",               -- dst MAC = requester
    x"02", x"AA", x"BB", x"CC", x"DD", x"EE",               -- src MAC = DUT
    x"08", x"06",                                           -- EtherType ARP
    x"00", x"01", x"08", x"00", x"06", x"04", x"00", x"02", -- OPER=Reply
    x"02", x"AA", x"BB", x"CC", x"DD", x"EE",               -- SHA = DUT
    x"C0", x"A8", x"01", x"01",                             -- SPA = DUT IP
    x"00", x"11", x"22", x"33", x"44", x"55",               -- THA = requester
    x"C0", x"A8", x"01", x"64"                              -- TPA = requester IP
  );

begin

  uut: entity work.arp_responder(rtl)
    generic map (
      IP_ADDRESS  => x"C0A80101",
      MAC_ADDRESS => x"02AABBCCDDEE"
    )
    port map (
      clock     => clock,
      reset     => reset,

      in_ready  => in_ready,
      in_valid  => in_valid,
      in_data   => in_data,
      in_sop    => in_sop,
      in_eop    => in_eop,

      out_ready => out_ready,
      out_valid => out_valid,
      out_data  => out_data,
      out_sop   => out_sop,
      out_eop   => out_eop
    );

  ------------------------------------------------------------------------------
  -- Clock
  ------------------------------------------------------------------------------
  clock_gen : process
  begin
    while true loop
      clock <= '1'; wait for tclk/2;
      clock <= '0'; wait for tclk/2;
    end loop;
  end process;

  ------------------------------------------------------------------------------
  -- Reset: dr?i 1 jedan takt, pa spusti
  ------------------------------------------------------------------------------
  rst_gen : process
begin
  reset <= '1';

  -- poravnaj se na clock ivice

  wait until rising_edge(clock);
  reset <= '0';                   -- deassert na rising edge (sinhrono)

  wait;
end process;

  ------------------------------------------------------------------------------
  -- Stimulus (ULAZ): Avalon-ST source mora drzati valid/data/sop/eop stabilno
  -- dok je in_ready=0. Ovdje napredujemo samo kad je in_ready=1.
  ------------------------------------------------------------------------------
  stim_proc : process
  variable i : integer := 0;
begin
  in_valid <= '0';
  in_sop   <= '0';
  in_eop   <= '0';
  in_data  <= (others => '0');

  wait until reset = '0';

  -- pauza 1 pun takt nakon reseta
  wait until rising_edge(clock);


  -- postavi byte0 (SOP) na falling edge, da DUT vidi stabilno na rising edge
  i := 0;
  in_valid <= '1';
  in_data  <= arp_req(i);
  in_sop   <= '1';
  in_eop   <= '0';

  while i <= 41 loop
    wait until rising_edge(clock);

    if in_ready = '1' then
      i := i + 1;

      if i <= 41 then
        -- opet postavi sljedeci bajt na falling edge (stabilno prije rising edge)
        in_data <= arp_req(i);
        in_sop  <= '0';
        if i = 41 then
          in_eop <= '1';
        else
          in_eop <= '0';
        end if;
      else
        in_valid <= '0';
        in_sop   <= '0';
        in_eop   <= '0';
        in_data  <= (others => '0');
      end if;
    end if;
  end loop;

  wait;
end process;


  ------------------------------------------------------------------------------
  -- OUT READY: provjera samo na izlazu
  -- Spustamo out_ready na par taktova usred TX da provjerimo HOLD ponasanje.
  ------------------------------------------------------------------------------
  out_ready_proc : process
    variable tx_cnt : integer := 0;
  begin
    out_ready <= '1';
    wait until reset = '0';

    -- cekaj pocetak reply-a
    loop
      wait until rising_edge(clock);
      wait for 0 ns;
      exit when (out_valid='1' and out_sop='1');
    end loop;

    -- pusti 10 handshake transfera
    tx_cnt := 0;
    while tx_cnt < 10 loop
      wait until rising_edge(clock);
      wait for 0 ns;
      if (out_valid='1' and out_ready='1') then
        tx_cnt := tx_cnt + 1;
      end if;
    end loop;

    -- stall 3 ciklusa 
    wait until falling_edge(clock);
    out_ready <= '0';
    for k in 1 to 3 loop
      wait until rising_edge(clock);
    end loop;
    wait until falling_edge(clock);
    out_ready <= '1';

    wait;
  end process;

  ------------------------------------------------------------------------------
  -- CHECKER:
  -- 1) provjerava sadrzaj ARP Reply bajt-po-bajt na HANDSHAKE (out_valid && out_ready)
  -- 2) provjerava HOLD: kad je out_valid=1 i out_ready=0, out_data/sop/eop MORAJU ostati stabilni
  --    (odmah od prvog stall ciklusa).
  ------------------------------------------------------------------------------
  check_proc : process
    variable exp_i        : integer := 0;
    variable ok           : boolean := true;

    variable prev_valid   : std_logic := '0';
    variable prev_ready   : std_logic := '1';
    variable prev_data    : std_logic_vector(7 downto 0) := (others => '0');
    variable prev_sop     : std_logic := '0';
    variable prev_eop     : std_logic := '0';
  begin
    wait until reset = '0';

    -- nadji ciklus byte0 (SOP)
    loop
      wait until rising_edge(clock);
      wait for 0 ns;
      exit when (out_valid='1' and out_sop='1');
    end loop;

    exp_i := 0;

    while true loop

      -- HOLD provjera: ako je prethodni ciklus bio stall (valid=1, ready=0),
      -- onda i sada mora ostati valid=1 i podaci moraju biti isti.
      if (prev_valid='1' and prev_ready='0') then
        if out_valid /= '1' then
          report "GRESKA: out_valid mora ostati '1' dok je out_ready='0' (Avalon-ST)" severity error;
          ok := false;
        end if;

        if out_data /= prev_data then
          report "GRESKA: out_data se promijenio dok out_ready='0'" severity error;
          ok := false;
        end if;

        if out_sop /= prev_sop then
          report "GRESKA: out_sop se promijenio dok out_ready='0'" severity error;
          ok := false;
        end if;

        if out_eop /= prev_eop then
          report "GRESKA: out_eop se promijenio dok out_ready='0'" severity error;
          ok := false;
        end if;
      end if;

      if out_valid = '1' then
        -- provjera ocekivanog bajta (vazi i kad je ready=0, jer DUT mora drzati isti bajt)
        if out_data /= arp_reply_exp(exp_i) then
          report "GRESKA: out_data mismatch na exp byte " & integer'image(exp_i) severity error;
          ok := false;
        end if;

        if exp_i = 0 then
          if out_sop /= '1' then
            report "GRESKA: out_sop mora biti '1' na bajtu 0" severity error;
            ok := false;
          end if;
        else
          if out_sop /= '0' then
            report "GRESKA: out_sop mora biti '0' osim na bajtu 0" severity error;
            ok := false;
          end if;
        end if;

        if exp_i = 41 then
          if out_eop /= '1' then
            report "GRESKA: out_eop mora biti '1' na bajtu 41" severity error;
            ok := false;
          end if;
        else
          if out_eop /= '0' then
            report "GRESKA: out_eop ne smije biti '1' prije bajta 41" severity error;
            ok := false;
          end if;
        end if;

        -- napredovanje samo na HANDSHAKE
        if (out_ready = '1') then
          if exp_i = 41 then
            exit;
          else
            exp_i := exp_i + 1;
          end if;
        end if;
      end if;

      -- upamti trenutno stanje (za HOLD provjeru u sljedecem ciklusu)
      prev_valid := out_valid;
      prev_ready := out_ready;
      prev_data  := out_data;
      prev_sop   := out_sop;
      prev_eop   := out_eop;

      wait until rising_edge(clock);
      wait for 0 ns;
    end loop;

    if ok then
      report "SCENARIJ 1 OK: ARP Reply identican ocekivanom (provjeren)." severity note;
    else
      report "SCENARIJ 1: zavrseno, ali ima GRESAKA (vidi error poruke)." severity error;
    end if;

    wait;
  end process;

end architecture;

